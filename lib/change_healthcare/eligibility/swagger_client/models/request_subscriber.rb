# #Eligibility
#
# Reference for developers
#
# OpenAPI spec version: v3
#
# Generated by: https://github.com/swagger-api/swagger-codegen.git
# Swagger Codegen version: 2.4.17
#

require 'date'

module ChangeHealthcare
  module Eligibility
    module SwaggerClient
      # Loop: 2100C, Notes: Subscriber Detail
      class RequestSubscriber
        # Loop: 2100[C|D], Segment: REF Notes: Additional Identification
        attr_accessor :additional_identification

        # Loop: 2100[C|D], Segment: N3 and N4, Notes: Address
        attr_accessor :address

        # Loop: 2110[C|D], Segment: DTP, Element: DTP03, Notes: DTP01=102, DTP02=RD8 Retired
        attr_accessor :beginning_card_issue_date

        # Loop: 2110[C|D], Segment: DTP, Element: DTP03, Notes: DTP01=291, DTP02=RD8 Retired
        attr_accessor :beginning_plan_issue_date

        # Loop: 2100C Segment: INS, Element: INS17, Notes: Birth Sequence Number - must be exactly 9 positive unsigned numeric characters.
        attr_accessor :birth_sequence_number

        # Loop: 2100C Segment: REF, Element: REF02, Notes: REF01=3H Case Number
        attr_accessor :case_number

        # Loop: 2110C Segment: EQ, Element: EQ03, Notes: Retired, Not Used
        attr_accessor :coverage_level_code

        # Loop: 2100[C|D], Segment: DMG, Element: DMG02, Notes: date of birth in CCYYMMDD
        attr_accessor :date_of_birth

        # Loop: 2110[C|D], Segment: DTP, Element: DTP03, Notes: DTP01=102, DTP02=RD8 Retired
        attr_accessor :end_card_issue_date

        # Loop: 2110[C|D], Segment: DTP, Element: DTP03, Notes: DTP01=291, DTP02=RD8 Retired
        attr_accessor :end_plan_issue_date

        # Loop: 2100[C|D], Segment: MN1, Element: NM104, Notes: firstName 1-35 alphanumberic characters
        attr_accessor :first_name

        # Loop: 2100[C|D], Segment: DMG, Element: DMG03, Notes: gender 1 character 'M' or 'F'
        attr_accessor :gender

        # Loop: 2100[C|D], Segment: REF, Element: REF02, Notes: REF01=6P Group Number
        attr_accessor :group_number

        # Loop: 2100[C|D], Segment: HI, Element: HI01-1 HI01-2, Notes: Health Care Diagnosis
        attr_accessor :health_care_code_information

        # Loop: 2100[C|D], Segment: REF, Element: REF02, Notes: REF01=HJ Identity Card Number
        attr_accessor :id_card

        # Loop: 2110[C|D], Segment: DTP, Element: DTP03, Notes: DTP01=102, DTP02=D8 Retired
        attr_accessor :id_card_issue_date

        # Loop: 2100[C|D], Segment: MN1, Element: NM103, Notes: lastName 1-60 alphanumberic characters
        attr_accessor :last_name

        # Loop: 2110C Segment: REF, Element: REF02, Notes: REF01=NQ Medicaid Recipient Identification Number
        attr_accessor :medicaid_recipient_identification_number

        # Loop: 2100[C|D] Segment: MN1, Element: NM109, Notes: NM108=MI, memberId 2-80 alphanumberic characters
        attr_accessor :member_id

        # Loop: 2100[C|D], Segment: MN1, Element: NM105, Notes: middleName 1-25 alphanumberic characters
        attr_accessor :middle_name

        # Loop: 2110[C|D], Segment: DTP, Element: DTP03, Notes: DTP01=291, DTP02=D8 Retired
        attr_accessor :plan_issue_date

        # Loop: 2100[C|D], Segment: PRV, Element: PRV01, Notes: Provider Code
        attr_accessor :provider_code

        # Loop: 2100[C|D], Segment: PRV, Element: PRV03, Notes: Provider Identifier
        attr_accessor :provider_identifier

        # Loop: 2100[C|D], Segment: PRV, Element: PRV02, Notes: Reference Identification Qualifier
        attr_accessor :reference_identification_qualifier

        # Loop: 2110C Segment: ATM, Element: ATM02, Notes: ATM01=R Spend Down
        attr_accessor :spend_down_amount

        # Loop: 2110C Segment: ATM, Element: ATM02, Notes: ATM01=PB Billed Amount
        attr_accessor :spend_down_total_billed_amount

        # Loop: 2100[C|D], Segment: REF, Element: REF02, Notes: REF01=SY Social Security Number
        attr_accessor :ssn

        # Loop: 2100[C|D], Segment: MN1, Element: NM107, Notes: lastName 1-10 alphanumberic characters
        attr_accessor :suffix

        class EnumAttributeValidator
          attr_reader :datatype, :allowable_values

          def initialize(datatype, allowable_values)
            @allowable_values = allowable_values.map do |value|
              case datatype.to_s
              when /Integer/i
                value.to_i
              when /Float/i
                value.to_f
              else
                value
              end
            end
          end

          def valid?(value)
            !value || allowable_values.include?(value)
          end
        end

        # Attribute mapping from ruby-style variable name to JSON key.
        def self.attribute_map
          {
            'additional_identification': :additionalIdentification,
            'address': :address,
            'beginning_card_issue_date': :beginningCardIssueDate,
            'beginning_plan_issue_date': :beginningPlanIssueDate,
            'birth_sequence_number': :birthSequenceNumber,
            'case_number': :caseNumber,
            'coverage_level_code': :coverageLevelCode,
            'date_of_birth': :dateOfBirth,
            'end_card_issue_date': :endCardIssueDate,
            'end_plan_issue_date': :endPlanIssueDate,
            'first_name': :firstName,
            'gender': :gender,
            'group_number': :groupNumber,
            'health_care_code_information': :healthCareCodeInformation,
            'id_card': :idCard,
            'id_card_issue_date': :idCardIssueDate,
            'last_name': :lastName,
            'medicaid_recipient_identification_number': :medicaidRecipientIdentificationNumber,
            'member_id': :memberId,
            'middle_name': :middleName,
            'plan_issue_date': :planIssueDate,
            'provider_code': :providerCode,
            'provider_identifier': :providerIdentifier,
            'reference_identification_qualifier': :referenceIdentificationQualifier,
            'spend_down_amount': :spendDownAmount,
            'spend_down_total_billed_amount': :spendDownTotalBilledAmount,
            'ssn': :ssn,
            'suffix': :suffix
          }
        end

        # Attribute type mapping.
        def self.swagger_types
          {
            'additional_identification': :AdditionalIdentification,
            'address': :Address,
            'beginning_card_issue_date': :String,
            'beginning_plan_issue_date': :String,
            'birth_sequence_number': :String,
            'case_number': :String,
            'coverage_level_code': :String,
            'date_of_birth': :String,
            'end_card_issue_date': :String,
            'end_plan_issue_date': :String,
            'first_name': :String,
            'gender': :String,
            'group_number': :String,
            'health_care_code_information': :'Array<HealthCareInformation>',
            'id_card': :String,
            'id_card_issue_date': :String,
            'last_name': :String,
            'medicaid_recipient_identification_number': :String,
            'member_id': :String,
            'middle_name': :String,
            'plan_issue_date': :String,
            'provider_code': :String,
            'provider_identifier': :String,
            'reference_identification_qualifier': :String,
            'spend_down_amount': :String,
            'spend_down_total_billed_amount': :String,
            'ssn': :String,
            'suffix': :String
          }
        end

        # Initializes the object
        # @param [Hash] attributes Model attributes in the form of hash
        def initialize(attributes = {})
          return unless attributes.is_a?(Hash)

          # convert string to symbol for hash key
          attributes = attributes.transform_keys(&:to_sym)

          self.additional_identification = attributes[:additionalIdentification] if attributes.key?(:additionalIdentification)

          self.address = attributes[:address] if attributes.key?(:address)

          self.beginning_card_issue_date = attributes[:beginningCardIssueDate] if attributes.key?(:beginningCardIssueDate)

          self.beginning_plan_issue_date = attributes[:beginningPlanIssueDate] if attributes.key?(:beginningPlanIssueDate)

          self.birth_sequence_number = attributes[:birthSequenceNumber] if attributes.key?(:birthSequenceNumber)

          self.case_number = attributes[:caseNumber] if attributes.key?(:caseNumber)

          self.coverage_level_code = attributes[:coverageLevelCode] if attributes.key?(:coverageLevelCode)

          self.date_of_birth = attributes[:dateOfBirth] if attributes.key?(:dateOfBirth)

          self.end_card_issue_date = attributes[:endCardIssueDate] if attributes.key?(:endCardIssueDate)

          self.end_plan_issue_date = attributes[:endPlanIssueDate] if attributes.key?(:endPlanIssueDate)

          self.first_name = attributes[:firstName] if attributes.key?(:firstName)

          self.gender = attributes[:gender] if attributes.key?(:gender)

          self.group_number = attributes[:groupNumber] if attributes.key?(:groupNumber)

          if attributes.key?(:healthCareCodeInformation)
            if (value = attributes[:healthCareCodeInformation]).is_a?(Array)
              self.health_care_code_information = value
            end
          end

          self.id_card = attributes[:idCard] if attributes.key?(:idCard)

          self.id_card_issue_date = attributes[:idCardIssueDate] if attributes.key?(:idCardIssueDate)

          self.last_name = attributes[:lastName] if attributes.key?(:lastName)

          if attributes.key?(:medicaidRecipientIdentificationNumber)
            self.medicaid_recipient_identification_number = attributes[:medicaidRecipientIdentificationNumber]
          end

          self.member_id = attributes[:memberId] if attributes.key?(:memberId)

          self.middle_name = attributes[:middleName] if attributes.key?(:middleName)

          self.plan_issue_date = attributes[:planIssueDate] if attributes.key?(:planIssueDate)

          self.provider_code = attributes[:providerCode] if attributes.key?(:providerCode)

          self.provider_identifier = attributes[:providerIdentifier] if attributes.key?(:providerIdentifier)

          self.reference_identification_qualifier = attributes[:referenceIdentificationQualifier] if attributes.key?(:referenceIdentificationQualifier)

          self.spend_down_amount = attributes[:spendDownAmount] if attributes.key?(:spendDownAmount)

          self.spend_down_total_billed_amount = attributes[:spendDownTotalBilledAmount] if attributes.key?(:spendDownTotalBilledAmount)

          self.ssn = attributes[:ssn] if attributes.key?(:ssn)

          self.suffix = attributes[:suffix] if attributes.key?(:suffix)
        end

        # Show invalid properties with the reasons. Usually used together with valid?
        # @return Array for valid properties with the reasons
        def list_invalid_properties
          []
        end

        # Check to see if the all the properties in the model are valid
        # @return true if the model is valid
        def valid?
          provider_code_validator = EnumAttributeValidator.new('String', %w[AD AT BI CO CV H HH LA OT P1 P2 PC PE R RF SK SU])
          return false unless provider_code_validator.valid?(@provider_code)

          reference_identification_qualifier_validator = EnumAttributeValidator.new('String', %w[9K D3 EI HPI PXC SY TJ])
          return false unless reference_identification_qualifier_validator.valid?(@reference_identification_qualifier)

          true
        end

        # Custom attribute writer method checking allowed values (enum).
        # @param [Object] provider_code Object to be assigned
        def provider_code=(provider_code)
          validator = EnumAttributeValidator.new('String', %w[AD AT BI CO CV H HH LA OT P1 P2 PC PE R RF SK SU])
          raise ArgumentError, %(invalid value for "provider_code", must be one of #{validator.allowable_values}.) unless validator.valid?(provider_code)

          @provider_code = provider_code
        end

        # Custom attribute writer method checking allowed values (enum).
        # @param [Object] reference_identification_qualifier Object to be assigned
        def reference_identification_qualifier=(reference_identification_qualifier)
          validator = EnumAttributeValidator.new('String', %w[9K D3 EI HPI PXC SY TJ])
          unless validator.valid?(reference_identification_qualifier)
            raise ArgumentError, %(invalid value for "reference_identification_qualifier", must be one of #{validator.allowable_values}.)
          end

          @reference_identification_qualifier = reference_identification_qualifier
        end

        # Checks equality by comparing each attribute.
        # @param [Object] Object to be compared
        def ==(o)
          return true if equal?(o)

          self.class == o.class &&
            additional_identification == o.additional_identification &&
            address == o.address &&
            beginning_card_issue_date == o.beginning_card_issue_date &&
            beginning_plan_issue_date == o.beginning_plan_issue_date &&
            birth_sequence_number == o.birth_sequence_number &&
            case_number == o.case_number &&
            coverage_level_code == o.coverage_level_code &&
            date_of_birth == o.date_of_birth &&
            end_card_issue_date == o.end_card_issue_date &&
            end_plan_issue_date == o.end_plan_issue_date &&
            first_name == o.first_name &&
            gender == o.gender &&
            group_number == o.group_number &&
            health_care_code_information == o.health_care_code_information &&
            id_card == o.id_card &&
            id_card_issue_date == o.id_card_issue_date &&
            last_name == o.last_name &&
            medicaid_recipient_identification_number == o.medicaid_recipient_identification_number &&
            member_id == o.member_id &&
            middle_name == o.middle_name &&
            plan_issue_date == o.plan_issue_date &&
            provider_code == o.provider_code &&
            provider_identifier == o.provider_identifier &&
            reference_identification_qualifier == o.reference_identification_qualifier &&
            spend_down_amount == o.spend_down_amount &&
            spend_down_total_billed_amount == o.spend_down_total_billed_amount &&
            ssn == o.ssn &&
            suffix == o.suffix
        end

        # @see the `==` method
        # @param [Object] Object to be compared
        def eql?(o)
          self == o
        end

        # Calculates hash code according to all attributes.
        # @return [Fixnum] Hash code
        def hash
          [additional_identification, address, beginning_card_issue_date, beginning_plan_issue_date, birth_sequence_number, case_number, coverage_level_code, date_of_birth, end_card_issue_date, end_plan_issue_date, first_name, gender, group_number, health_care_code_information, id_card, id_card_issue_date, last_name, medicaid_recipient_identification_number, member_id, middle_name, plan_issue_date, provider_code, provider_identifier, reference_identification_qualifier, spend_down_amount, spend_down_total_billed_amount, ssn, suffix].hash
        end

        # Builds the object from hash
        # @param [Hash] attributes Model attributes in the form of hash
        # @return [Object] Returns the model itself
        def build_from_hash(attributes)
          return nil unless attributes.is_a?(Hash)

          self.class.swagger_types.each_pair do |key, type|
            if type =~ /\AArray<(.*)>/i
              # check to ensure the input is an array given that the attribute
              # is documented as an array but the input is not
              if attributes[self.class.attribute_map[key]].is_a?(Array)
                send("#{key}=", attributes[self.class.attribute_map[key]].map { |v| _deserialize(Regexp.last_match(1), v) })
              end
            elsif !attributes[self.class.attribute_map[key]].nil?
              send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
            end # or else data not found in attributes(hash), not an issue as the data can be optional
          end

          self
        end

        # Deserializes the data based on type
        # @param string type Data type
        # @param string value Value to be deserialized
        # @return [Object] Deserialized data
        def _deserialize(type, value)
          case type.to_sym
          when :DateTime
            DateTime.parse(value)
          when :Date
            Date.parse(value)
          when :String
            value.to_s
          when :Integer
            value.to_i
          when :Float
            value.to_f
          when :BOOLEAN
            if value.to_s =~ /\A(true|t|yes|y|1)\z/i
              true
            else
              false
            end
          when :Object
            # generic object (usually a Hash), return directly
            value
          when /\AArray<(?<inner_type>.+)>\z/
            inner_type = Regexp.last_match[:inner_type]
            value.map { |v| _deserialize(inner_type, v) }
          when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
            k_type = Regexp.last_match[:k_type]
            v_type = Regexp.last_match[:v_type]
            {}.tap do |hash|
              value.each do |k, v|
                hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
              end
            end
          else # model
            temp_model = SwaggerClient.const_get(type).new
            temp_model.build_from_hash(value)
          end
        end

        # Returns the string representation of the object
        # @return [String] String presentation of the object
        def to_s
          to_hash.to_s
        end

        # to_body is an alias to to_hash (backward compatibility)
        # @return [Hash] Returns the object in the form of hash
        def to_body
          to_hash
        end

        # Returns the object in the form of hash
        # @return [Hash] Returns the object in the form of hash
        def to_hash
          hash = {}
          self.class.attribute_map.each_pair do |attr, param|
            value = send(attr)
            next if value.nil?

            hash[param] = _to_hash(value)
          end
          hash
        end

        # Outputs non-array value in the form of hash
        # For object, use to_hash. Otherwise, just return the value
        # @param [Object] value Any valid value
        # @return [Hash] Returns the value in the form of hash
        def _to_hash(value)
          if value.is_a?(Array)
            value.compact.map { |v| _to_hash(v) }
          elsif value.is_a?(Hash)
            {}.tap do |hash|
              value.each { |k, v| hash[k] = _to_hash(v) }
            end
          elsif value.respond_to? :to_hash
            value.to_hash
          else
            value
          end
        end
      end
    end
  end
end
